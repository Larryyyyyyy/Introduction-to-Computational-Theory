# 第1章 计算理论

## 1.1图灵机

一台$k$-带图灵机（**TM**）$\mathbb M$ 有 $k$-条带子。第一条带子称为**输入带**，用来存放输入数据，是只读带。其余$k-1$条带子是工作带 ，可读可写。一条带子被分成了潜在无穷多个格子，每个格子内可以存放一个符号，用$0,1,2,\dots$标注格子的地址。每条带子有一个**读写头**，它指向带子上的某一个，该时刻读写头只能对这一格里的符号进行读或改写。

> [!NOTE]
>
> **定义1.1**：一台$k$-带图灵机是一个三元组$(\Gamma,Q,\delta)$，其中
>
> 1. $\Gamma$是有限符号集，至少包含$0、1、\square、\triangleright$；
> 2. $Q$是有限状态集，必须包含起始状态$q_{start}$和终止状态$q_{halt}$；
> 3. $\delta:Q\times\Gamma^k\to Q\times\Gamma^{k-1}\times\{L,S,R\}^k$是迁移函数。

**初始化**：

1. $\triangleright$预置在每条带子最左端格子里，图灵机不对第$0$格作修改，也不在其它格子写入$\triangleright$。
2. 所有工作带格子均放着$\square$，表示无用信息。
3. 输入带除了输入符号串的格子外全放着$\square$。

图灵机始于$q_{start}$，终于$q_{halt}$。

**迁移函数**$\delta$：$\delta(q,a_1,\dots,a_k)=(q',a_2',\dots,a_k',A_1,\dots,A_k)$等价于$(q,a_1,\dots,a_k)\to(q',a_2',\dots,a_k',A_1,\dots,A_k)$。

后者被称为一条**指令**。

$A_i\in\{L,S,R\}$表示第$i$个读写头的移动。

执行一次指令，图灵机完成了**一步计算**。

规定$\delta(q_{halt},a_1,a_2,\dots,a_k)=(q_{halt},a_2,\dots,a_k,S,\dots,S)$。当机器进入停机状态$q_{halt}$时，机器不再进行任何计算。

$\mathbb{M}(x)$表示图灵机$\mathbb M$的输入带预置了输入$x$。

在计算的任何时刻$t$，$\mathbb M(x)$的**格局**$\sigma_t$是一个$2k-$元组$(q,\kappa_2,\dots,\kappa_k,h_1,\dots,h_k)$，它的含义与指令中后半部分类似：$\kappa_i$表示时刻$t$时$k-1$条工作带的内容（非$\square$的符号串），$h_i$表示时刻$t$时$k$个读写头位置。

$\mathbb M(x)$的**初始格局**是$(q_{start},\epsilon,\dots,\epsilon,0,\dots,0)$，是唯一的。

$\mathbb M(x)$的**终止格局**是状态为$q_{halt}$的格局。

一步计算可以写作$\sigma_t\to\sigma_{t+1}$，对于格局迁移序列$\sigma_0\to\sigma_1\to\dots\to\sigma_t\to\dots$，若该计算终止，记为$\mathbb M(x)\downarrow$，否则记为$\mathbb M(x)\uparrow$。若计算终止于$\sigma_T$，则$\sigma_0\to\sigma_1\to\dots\to\sigma_T$表示其**计算路径**，计算路径长度被称为该计算的**计算步数**或**计算时间**。

**时间函数**$T:\N\to\N$，通常地，是从串的长度$n$到计算时间的一个上界的映射。

一个函数$f:\{0,1\}^*\to\{0,1\}^*$是一个**问题**。$\mathbb M(x)=y$表示$\mathbb M(x)\downarrow$且计算终止时输出带上的内容是$y$，称$y$是$\mathbb M(x)$的**计算结果**。若对任意输入$x\in\{0,1\}^*$，有$\mathbb M(x)=f(x)$，称$\mathbb M$**计算**$f$或$\mathbb M$**解决问题**$f$。

**判定问题**是一个函数$d:\{0,1\}^*\to\{0,1\}$，若$\mathbb M$解决$d$，也称$\mathbb M$**判定**$d$。称$\{0,1\}^*$的一个子集$L$为**语言**。

若图灵机$\mathbb M$判定$L$的**特征函数**
$$
L(x)=\begin{cases}1,&若x\in L\\0,&若x\notin L\end{cases}
$$
称$\mathbb M$**接受语言**$L$，或称$L$为**可判定的**。

> [!NOTE]
>
> **定义1.2**：一个判定问题$A\subseteq\{0,1\}^*$的补问题$\overline{A}$定义为$\{0,1\}^*\textbackslash A$

> [!CAUTION]
>
> 教材与本笔记中，如果一个数学表达式求值结果不是整数，自动**向上取整**。用$\llcorner n\lrcorner$表示数的二进制形式。

称一个函数是**图灵机可计算的**或**图灵机可解的**，当且仅当有一台图灵机计算它。

## 1.2时间可构造性

设$T(n):\N\to\N$为时间函数且$L\subseteq\{0,1\}^*$为可判定问题。若存在判定$L$的图灵机$\mathbb M$和常数$c>0$，对任意输入$x$，$\mathbb M$在$cT(|x|)$步内停机，则称$L$在$\bold{TIME}(T(n))$中。

一般地，$\bold{TIME}(T(n))$依赖于所用模型，如图灵机的带数。

我们假定所关注的图灵机必须将输入完整地读一遍，也就是$T(n)\ge n$。

> [!NOTE]
>
> **定义1.3**：若有图灵机在$O(T(n))$时间内计算函数$1^n\mapsto\llcorner T(n)\lrcorner$，称$T(n)$是**时间可构造的**。

根据线性加速定理，我们可以给出下一个定义：

> [!NOTE]
>
> **定义1.4**：若有图灵机在输入$1^n$上准确地计算了$T(n)$步后停机，称$T(n)$是**完全时间可构造的**。

设$\mathbb M=(Q_0,\Gamma_0,\to_0)$为一行为不规则的$k_0$-带图灵机，$\mathbb T=(Q_1,\Gamma_1,\to_1)$是一$k_1$-带时钟图灵机，将它们复合：

- $Q=Q_0\times Q_1$，对于所有$q\in Q_0$引入$(q,q_{halt}^1)=q_{halt}$，$q\in Q_1$引入$(q_{halt}^0,q)=q_{halt}$。
- $\Gamma=\Gamma_0\times\Gamma_1$。
- $\to=\to_0\times\to_1$。

效果相当于$\mathbb T$对$\mathbb M$的计算掐表，强迫后者在规定时间内停机。我们称$\mathbb T$是**时钟图灵机**，复合后的图灵机是$\mathbb M$和$\mathbb T$的**硬连接**。

## 1.3通用图灵机

**事实**：无法设计一套编码系统，使得本质上相同的图灵机有相同的编码。

**原因**：无法设计一个算法测试两台图灵机是否相等。

> [!CAUTION]
>
> $\llcorner\mathbb M\lrcorner$表示图灵机$\mathbb M$的二进制编码，$\mathbb M_\alpha$表示二进制编码为$\alpha$的图灵机。

对图灵机的有效枚举
$$
\mathbb M_0,\mathbb M_1,\dots,\mathbb M_i,\dots
$$
称$i$为图灵机$\mathbb M_i$的**下标**或**哥德尔编码**。

对**图灵机可计算**函数的枚举
$$
\phi_0,\phi_1,\dots,\phi_i,\dots
$$
其中
$$
\phi_i(x)\overset{\text{def}}{=}\begin{cases}y,&若\mathbb M_i(x)=y\\\uparrow,&若\mathbb M_i(x)\uparrow\end{cases}
$$
$\phi_i(x)$在输入$x$上无定义，记为$\phi_i(x)\uparrow$，当且仅当$\mathbb M_i(x)\uparrow$。$\phi_i(x)\downarrow$，当且仅当$\mathbb M_i(x)\downarrow$。

> [!NOTE]
>
> **定理1.1（枚举定理）**：存在**通用图灵机**$\mathbb U$，对任意$\alpha,x\in\{0,1\}^*$，等式$\mathbb U(\alpha,x)\simeq\mathbb M_\alpha(x)$成立。

上面$\simeq$的定义是两边要么同时有定义且相等要么都无定义。

> [!NOTE]
>
> **定理1.2**：存在通用图灵机$\mathbb U$和多项式$c$。对任意长度为$n$的输入串$x$，若$\mathbb M_\alpha(x)$在$T(n)$步内停机，则$\mathbb U(\alpha,x)$在$c(|\alpha|)T(n)\log T(n)$步内停机。

下面我们尽可能通俗地证明：

为了方便，设定图灵机的工作带是左右无限延伸的。

设$\mathbb M_\alpha$的工作带数为$k$，由于$k$可能很大，所以我们这么规定$\mathbb U$：

- $\mathbb U$的第一条工作带是主工作带，储存$\mathbb M_\alpha$的所有工作带上的内容，第二条带用来存储中间结果和提高数据移动效率。
- 我们把$\mathbb M_\alpha$的每条带内容依次放入主工作带，并用分隔符分开。主工作带上的每个单元格要么是分隔符，要么是$s_{i,j}$，表示第$i$个磁带上第$j$个单元格内容，且读写头**不在**这个单元格，要么是$s_{i,j}'$，表示第$i$个磁带上第$j$个单元格内容，且读写头**在**这个单元格。

$\mathbb M_\alpha$的一步计算，我们会扫描主工作带，找出每条带的读写头位置，据此查表（第二条带），得到迁移函数下一步会怎么做。

再扫描一遍带，在对应带区间写入修改的符号，然后在每个带区段内移动带头标记。

最坏情况下的一步计算，如果某段头已经在最左格了，再往左移动（记得证明开始的设定）。

此时一种做法是把该段左边的所有段都向左移动一格，这个操作会移动$O(T(|x|))$个符号。

所以在最坏情况下，$\mathbb U$模拟$\mathbb M_\alpha$所需的时间为$O(T(|x|)^2)$。

---

但是我们可以采取一种独到的数据结构模拟：

我们将$\mathbb U$分块，具体来说是从中心向左右扩散，块的大小依次为$1,2,4,\dots,2^{\log(T(n))}$，中心区间只包含地址是$0$的那个格子。形如：
$$
\dots L_2L_1L_00R_0R_1R_2\dots\\
|L_i|=|R_i|=2^{i+1}
$$
块中引入缓冲符号$\times$，我们希望$\times$尽量均匀地分布在主工作带上，这样可以通过覆盖$\times$进行小范围的移动，避免涉及到整层。

为了让缓冲符号均匀分布，我们要保证以下三守恒：

1. 每一个区间要么是满的（区间里面全是有效符号），要么是空的（区间里全是$\times$ ），要么是半满的（区间里恰有一半是$\times$ ）；
2. 区间$L_i$和$R_i$的有效符号之和恒为$2^{i+1}$个。也就是说，要么$L_i$满$R_i$空，要么$L_i$空$R_i$满，要么$L_i$和$R_i$都是半满；
3. $0$号位永不是$\times$。

初始化时，可以视所有$R$区间均是满的，而所有$L$区间均是空的。

在模拟$\mathbb M_\alpha$的带头移动时，不妨考虑这层上的内容左移一格，右半边如下操作：

1. 把$0$号位的值挪到第二条带上；
2. 向右扫描，直到遇见第一个不为空的区间$R_i$（半满或满），把该区间的从左向右$2^i$个有效值挪到第二条带上；
3. 返回$0$号位，并在$0$号位，$R_0,R_1,\dots,R_{i-1}$， 这些区间中分别按顺序写入$1,1,2,\dots,2^{i-1}$个来自于$R_i$区间的值。

最后区间$R_0,R_1,\dots,R_{i-1}$都由空变为了半满，而区间$R_i$少了一半。

接下来左半边的操作：

1. 把区间$L_{i-1},\dots,L_0$所有的值挪到第二条带上。它们一定是满的；
2. 在区间$L_i,\dots,L_1$按顺序分别写入上一步中的$2^i，2^{i-1},\dots,2$个值；
3. 在区间$L_0$写入$0$号位原始的值。

最后区间$L_{i-1},\dots,L_0$都由满变为了半满，而区间$L_i$增加了一半。

至于右移的情况，镜像即可。

我们考虑最坏的情况：一次带子的左移涉及到了$R_i$ ，此后$R_0$至$R_{i-1}$都为半满，带子继续一个劲地左移，要移动$1+2+4+\dots+2^{i-1}=2^i-1$次清空$R_0$至$R_{i-1}$的所有内容，再下一次左移才会再次涉及到$R_i$。也就是说，两次涉及到区间$R_i$的移动的间隔至少为$2^i$。

带子的移动至多为$T$次，那么对区间$R_i$的操作不超过$\frac{T}{2^i}$次。最远对区间$R_i$进行操作时，$\mathbb U$需要扫描$L_i$至$R_i$的范围常数次，耗时$O(|\alpha|^c 2^i)$。而$i\in[1,\log(T(n))]$，那么$\mathbb U$的计算时间是
$$
O(\sum_{i=1}^{\log T(n)}\frac{T(n)}{2^i}|\alpha|^c2^i)=O(|\alpha|^cT(n)\log T(n)).
$$

---

接下来引入一个概念，若一台图灵机在任意时刻读写头的位置不依赖于输入的内容，而只依赖于输入的长度和该时刻已经进行的计算步数，称其为**健忘图灵机**。

> [!NOTE]
>
> **推论1.1**：设$T(n)$是时间可构造的，$L$可在$T(n)$时间内被一台图灵机判定。一定存在常数$C$和在$CT(n)\log T(n)$时间内判定$L$的健忘图灵机。

证明略。

> [!NOTE]
>
> **推论1.2**：设$f\in\bold{TIME}(T(n))$。有一台双读写带图灵机在$O(T(n)\log T(n))$时间内计算$f$。有一台单独写带的图灵机在$O(T(n)^2)$时间内计算$f$。

将$\mathbb U$的输入带和主工作带合二为一。如果只有一条读写带，数据移动需要$O(T(n)^2)$的时间。

## 1.4对角线方法

技术上，对角线方法必须用到通用图灵机。

考虑如下判定问题：
$$
\text{UC}(\alpha)=\begin{cases}0,&若\mathbb M_\alpha(\alpha)=1\\1,&若\mathbb M_\alpha(\alpha)\ne1 (包括\mathbb M_\alpha(\alpha)不会停机)\end{cases}
$$
假定$\text{UC}$可由$\mathbb{UC}$判定，就有$\mathbb{UC}(\llcorner\mathbb{UC}\lrcorner)=0$当且仅当$\mathbb{UC}(\llcorner\mathbb{UC}\lrcorner)=1$，矛盾。

---

定义函数
$$
\text H(\alpha,x)=\begin{cases}1,&若\mathbb M_\alpha(x)\downarrow\\0,&若\mathbb M_\alpha(x)\uparrow\end{cases}
$$
如果$\text H$是可计算的，那么我们可以判定任一问题对于任意输入是否会停机。

假设$\mathbb M$可以计算$\text{H}$，那么对于任意$\alpha$，都有
$$
\mathbb M(\alpha,\alpha)=\text H(\alpha,\alpha)=\begin{cases}1,&若\mathbb M_\alpha(\alpha)\downarrow\\0,&若\mathbb M_\alpha(\alpha)\uparrow\end{cases}
$$
那么存在图灵机$\mathbb N$可以判定$\text{UC}$
$$
\mathbb N(\alpha)=\begin{cases}0,&若\mathbb M(\alpha,\alpha)=1且\mathbb M_\alpha(\alpha)=1\\1,&\text{else}\end{cases}
$$
矛盾。

也就是**停机问题**不可判定。

## 1.6加速定理

加速定理说明了**不存在最优的算法**。

加速定理的证明及其推论有点困难，我们只证明**线性加速定理**。

> [!NOTE]
>
> **定理1.6（线性加速）**：设图灵机$\mathbb M$在$T(n)$步内判定$L$。对任意$\epsilon>0$，存在图灵机$\mathbb M'$，$\mathbb M'$能在$\epsilon T(n)+n+2$步内判定$L$。

我们试构造$\mathbb M'$：

- $\mathbb M'$用$n+2$步将输入转换成长度为$\frac{n}{m}$的内部符号串（作一个长度为$m$的符号串到长度为$1$的符号串映射），第$i$个内部符号串对应$\mathbb M$的第$i$个分块。
- $\mathbb M'$用$\frac{n}{m}$步移动读写头回第$0$格。
- 模拟$\mathbb M$的$m$步计算：
  $\mathbb M$的$m$步计算只有可能触及块$i$和块$i-1$和块$i+1$，且读写头的最终位置也只可能在块$i$和块$i-1$和块$i+1$。$\mathbb M'$，只需要遍历这三个单元格即可，最多的操作数是$5$。

从而$\mathbb M'$的计算时间不超过$n+2+\frac{n}{m}+\frac{5}{m}T(n)\le n+2+\frac{6}{m}T(n)$，令$m=\frac{6}{\epsilon}$即可。

当$T(n)$的增长速度严格大于线性函数时，我们有一个更简洁的加速定理：

> [!NOTE]
>
> **推论1.3**：设$T(n)=\omega(n)$，设图灵机$\mathbb M$在$T(n)$步内判定$L$。对任意$\epsilon >0$，存在图灵机$\mathbb M'$，$\mathbb M'$能在$\epsilon T(n)$步内判定$L$。

## 1.7时间复杂性类

一个**复杂性类**是一个模型无关的问题（存疑，我觉得是**语言**）类。最著名的一个复杂性类是**多项式时间类**，定义如下：
$$
\bold{P}=\bigcup_{c\ge 1}\bold{TIME}(n^c)
$$
$\bold P$的定义不依赖于任何模型。

**指数时间类**：
$$
\bold{EXP}=\bigcup_{c\ge 1}\bold{TIME}(2^{n^c})
$$
注意我们不能定义为$\bold{TIME}(2^{nc})$，如果我们把$\Theta(2^{nc})$的算法和$\Theta(n^3)$的算法复合，得到的也是指数算法，但不在$\bold{TIME}(2^{nc})$中。

我们用$\bold{coT}$表示$\bold T$的**补类**，即$\{\overline{A}|A\in\bold T\}$。

> [!NOTE]
>
> **引理1.3**：$\bold{coT}\subseteq\bold T$当仅当$\bold T\subseteq\bold{coT}$当仅当$\bold{coT}=\bold T$。

$\bold P=\bold{coP}$，这是因为$\bold P$由确定性图灵机$\mathbb M$定义，$\mathbb M$能判定$A$，那么$\mathbb M'$只是交换接收状态$q_{acc}$与拒绝状态$q_{rej}$也能判定$\overline{A}$，由于只改变了结果，判定过程不变，所以两台图灵机判定的问题的时间复杂性相同。

事实上任何由确定性图灵机定义的复杂性类都满足$\bold{coT}=\bold{T}$。

如果$\mathbb M$是不确定性图灵机，这个问题会非常有意思。

## 1.8非确定图灵机

一台**非确定图灵机**$\mathbb N$可以简单地定义为具有两个迁移函数$\delta_0$，$\delta_1$，它每时刻毫无章法地选择其中一个迁移函数计算。它常用来解决**存在性问题**。

非确定性图灵机每条计算路径试图构造一个存在性证明，若成功，在输出带上写$1$并停机，该终止格局为**接受格局**；若失败，在输出带上写$1$并停机，该终止格局为**拒绝格局**。

> [!NOTE]
>
> **定义1.6**：设$\mathbb N$为非确定图灵机，当输入$x$时，若$\mathbb N(x)$有一条计算路径终止于接受格局，称$\mathbb N$接受$x$，记为$\mathbb N(x)=1$。若$\mathbb N(x)$的所有的计算路径都不终止于接受格局，称$\mathbb N$拒绝$x$，记为$\mathbb N(x)=0$。

设$L$为一语言，若$x\in L$当仅当$\mathbb N(x)=1$，称$\mathbb N$接受$L$。

设$T:\mathbb N\to\mathbb N$为时间函数。对任意输入$x$，若非确定图灵机$\mathbb N$的任一计算路径长度都不超过$T(|x|)$，称$T(n)$为$\mathbb N$的时间函数。设$L\subseteq\{0,1\}^*$。记号$L\in\bold{NTIME}(T(n))$表示存在接受$L$的非确定图灵机$\mathbb N$和常数$c >0$，$cT(n)$为$\mathbb N$的时间函数。
$$
\bold{NP}=\bigcup_{c\ge 1}\bold{NTIME}(n^c)\\
\bold{NEXP}=\bigcup_{c\ge 1}\bold{NTIME}(2^{n^c})\\
$$

> [!NOTE]
>
> **命题1**：$\bold P\subseteq\bold{NP}\subseteq{\bold{EXP}}\subseteq\bold{NEXP}$。

非确定图灵机可以有效地被枚举
$$
\mathbb N_0,\mathbb N_1,\dots,\mathbb N_i,\dots
$$
此枚举满足：

- 所有非确定图灵机都出现过。
- 每个非确定图灵机都出现过无穷多次（为什么？）。

为定义通用非确定图灵机，引入如下定义。

> [!NOTE]
>
> **定义1.7**：设$\mathbb N$为$k$-带（非确定）图灵机，$x$为输入。$\mathbb N(x)$在第$t$步的**快照**为$k+1$元组
> $$
> \lang q,a_1,\dots,a_k\rang\in Q\times\underbrace{\Gamma\times\dots\times\Gamma}_{k}
> $$
> 其中，$q$为$t$时刻的机器状态，$a_1,\dots,a_k$为$t$时刻读写头所指格中的符号。

定义通用非确定图灵机$\mathbb V$如下：

1. 输入非确定图灵机编码$\alpha$和$0-1$串$x$。
2. $\mathbb V$猜测$\mathbb N_\alpha(x)$的一个终止于接受格局的计算路径的快照序列和一个同等长度的$0-1$串，后者表示$\mathbb N_\alpha$在计算时做的非确定选择，$0$表示选$\delta_0$，$1$表示选$\delta_1$。在猜测快照序列时，$\mathbb V$只跟踪输入带上的符号而忽略工作带，工作带上的符号通过猜测得到。
3. 对每一条工作带，$\mathbb V$验证在猜测阶段对该条工作带上猜测的符号是否正确。$\mathbb V$使用另一条工作带来记录$\mathbb N_\alpha$在该工作带上的实际读写过程。
4. 若所有验证均成功，$\mathbb V$停机并接受；若发现错误，$\mathbb V$停机并拒绝。

$\mathbb V$的最大优势是它几乎没有额外的时间开销，能在输入图灵机计算时间的一个常数倍里模拟输入图灵机的运行。$\mathbb V$的缺点是，它不一定终止，没有任何方法阻止它不停猜测。

> 可以理解为：$\mathbb V$以指数时间枚举，多项式时间验证。

回到**引理1.3**的讨论：

我们不能把证明$\bold{P}=\bold{coP}$的方法用在$\bold{NP}$时间复杂性类上，这是因为：

假设$\mathbb{M}_{NP}$是一个判定$L \in \mathbf{NP}$的$NTM$：

- 如果$w \in L$，只需一条计算路径在多项式时间内接受。
- 如果$w \notin L$，则所有计算路径都必须拒绝（或超时）。

如果我们简单地反转$\mathbb{M}_{NP}$的接受/拒绝状态得到$\mathbb{M}'$：

1. 如果$w \in L$：$\mathbb{M}_{NP}$有至少一条接受路径，和很多的拒绝路径。$\mathbb{M}'$沿着拒绝路径，会停在原来的$q_{rej}$，但现在被标记为$q'_{acc}$，所以$\mathbb{M}'$接受。
2. 如果$w \notin L$：$\mathbb{M}_{NP}$的所有路径都拒绝。$\mathbb{M}'$沿着这些路径，都会停在原来的$q_{rej}$，现在被标记为$q'_{acc}$。

坏了，$\mathbb M'$同时接受$L$和$\overline{L}$，然而它应该拒绝$L$。

目前$\bold{P}=\bold{NP}\Rightarrow\bold{NP}=\bold{coNP}$，只是这两个等号都没有确切的证明。

## 1.12时间谱系定理

给定时间函数$f$和$g$，$f\le g\Rightarrow\bold{TIME}(f(n))\subseteq\bold{TIME}(g(n))$，什么时候这个推论是严格的。

> [!NOTE]
>
> **定理1.8（时间谱系定理）**：若$f$和$g$是时间可构造的且$f(n)\log f(n)=o(g(n))$，则$\bold{TIME}(f(n))\subsetneq\bold{TIME}(g(n))$。

显然$\bold{TIME}f(n)\subset\bold{TIME}(g(n))$。

我们关心的是$\bold{TIME}(g(n))\nsubseteq\bold{TIME}(f(n))$。设$L$由如下定义的图灵机$\mathbb D$判定：

- 当输入$x$时，让$\mathbb U(x,x)$计算$g(|x|)$步；若$\mathbb U(x,x)$在$g(|x|)$步内完成模拟，输出$\mathbb M_x(x)$的反转$\overline{\mathbb M_x(x)}$，否则输出$0$。

此定义中，让$\mathbb U(x,x)$计算$g(|x|)$步指的是：

- 将图灵机$\lambda z.\mathbb U(z,z)$和$g(n)$-时钟图灵机进行硬连接，得到图灵机$\mathbb U_g$，然后计算$\mathbb U_g(x)$。

$L\in\bold{TIME}(g(n))$。假设$L\in\bold{TIME}(f(n))$，且$L$由图灵机$\mathbb M_z$在$f(n)$时间内判定。因为$f(n)\log f(n)=o(g(n))$，所以通用图灵机总能在$f(|z|)\log f(|z|)\le g(|z|)$时间内模拟完$\mathbb M_z(z)$的计算。因此：

- $\mathbb D(z)=\mathbb M_z(z)$，这是因为$\mathbb D$和$\mathbb M_z$都判定语言$L$。
- $\mathbb D(z)=\overline{\mathbb M_z(z)}$，这是因为$\mathbb D(z)$完成了对$\mathbb M_z$的模拟后将其结果反转。

> 这个证明的本质是**定理1.2**，即通用图灵机的极限效率决定了这个严格条件。

利用时间谱系定理，定义如下无穷多个复杂性类，它们构成一个严格包含序列：
$$
\begin{align}
\bold{EXP}&=\bigcup_{c>1}\bold{TIME}(2^{n^c})\\
\bold{2EXP}&=\bigcup_{c>1}\bold{TIME}(2^{2^{n^c}})\\
\bold{3EXP}&=\bigcup_{c>1}\bold{TIME}(2^{2^{2^{n^c}}})\\
&\vdots\\
\bold{ELEMENTARY}&=\bold{EXP}\cup\bold{2EXP}\cup\bold{3EXP}\cup\dots
\end{align}
$$
$\bold{ELEMENTARY}$就是**初等函数类**。书中顺带提到了任何初等函数的增长速度都小于$2^{\cdot^{\cdot^{\cdot^{2^{n}}}}}\rbrace{n}$，后者叫做**塔函数**。

> [!NOTE]
>
> **定理1.9（非确定时间谱系定理）**：若$f$和$g$为时间可构造，且$f(n+1)=o(g(n))$，则$\bold{NTIME}(f(n))\subsetneq\bold{NTIME}(g(n))$。

证明：

设一个精致的非确定图灵机$\mathbb Z$，定义为：

1. $\mathbb Z$的输入带上的读写头和第一条工作带上的读写头同步全速扫描：
   - 若输入长度是$1$或包含至少一个$0$，$\mathbb Z$停机并输出$0$。
   - 第一条工作带读写头第一格写$1$，大部分时间写$0$，偶尔写$1$，设$h_i(\text{i start from 0})$为第一条工作带上读写头写$1$的格子地址。
2. 第二条工作带上$\mathbb Z$枚举所有**非确定图灵机**和一个固定的$h(n)$-时钟图灵机硬连接，$h(n)=2f(n)$。设枚举为$\mathbb L_i\text{(i start from 1)}$。当$\mathbb Z$枚举完$\mathbb L_i$，依次做：
   - 暂停扫描。
   - 利用第一条工作带上的标记将$1^{h_{i-1}+1}$在第三条工作带上构造出来。（可以在上一次构造基础上额外构造$h_{i-1}-h_{i-2}$个$1$实现）
   - 将编码$\mathbb L_{i-1}$从第二条工作带上复制到第三条工作带上。
   - 将第一条工作带和第二条工作带上的读写头移到暂停之前位置。
   - 恢复扫描。同时$\mathbb Z$用暴力法计算$\mathbb L_{i-1}(1^{h_{i-1}+1})$。计算完成时，结果写在第二条工作带上，第一条工作带上写$1$，这个写$1$的格子地址就是$h_i$。之后，$\mathbb Z$在第二条工作带上枚举$\mathbb L_{i+1}$。
3. 设输入是$1^n$，其中$n>1$。当$\mathbb Z$扫描完输入：
   - 若$n=h_i$，$\mathbb Z$接受$1^n$当且仅当$\mathbb L_{i-1}(1^{h_{i-1}+1})=0$。
   - 若$h_{i-1}<n<h_i$，$\mathbb Z$非确定地让$\mathbb V(\mathbb L_{i-1},1^{n+1})$计算$g(n)$步（事实上这里计算$h(n)$步就能确保停机，选择$g(n)$是一种刻意）。

设$\mathbb Z$接受的语言是$L$：

说明$L\in\bold{NTIME}(g(n))$：

前两步的开销都是线性的，即使有暴力计算$\mathbb L_{i-1}(1^{h_{i-1}+1})$，由定义，这一步的开销也不会超过$h(n)$。第三步的两种情况的开销分别是$O(1)$和$O(g(n))$。

说明$L\notin\bold{NTIME}(f(n))$：

如果$L\in\bold{NTIME}(f(n))$，那么必然存在$\mathbb N=\mathbb L_i$在$O(f(n))$时间内接受$L$，不妨挑选一个**足够大**的$k$，使得：

1. $\mathbb N=\mathbb{L}_{k-1}$。

2. $\forall n \ge h_{k-1},f(n+1)<g(n)$。

   > 因为$f(n+1)=o(g(n))$。

**当$h_{k-1}<n<h_k$时：**

对于这个范围内的$n$：

$1^n\in L$（即$\mathbb{Z}$接受$1^n$）$\Leftrightarrow\mathbb{Z}$非确定地运行$\mathbb{V}(\mathbb{L}_{k-1},1^{n+1})$并在$g(n)$步内接受。

> - 由于$\mathbb N=\mathbb{L}_{k-1}$的运行时间是$f(n)$，所以$\mathbb N$在输入$1^{n+1}$上最多运行$f(n+1)$步就会停机。
> - 因为$k$足够大，使得$f(n+1)<g(n)$，所以$\mathbb{Z}$的$g(n)$步模拟必定能正确地计算出$\mathbb N(1^{n+1})$的最终结果。

因此，对于$h_{k-1} < n < h_k$：

$1^n \in L \Leftrightarrow \mathbb N(1^{n+1})$接受$\Leftrightarrow 1^{n+1} \in L$。

通过对$n$从$h_{k-1}+1$到$h_k-1$进行归纳，可以得到：

$1^{h_{k-1}+1} \in L \Leftrightarrow 1^{h_{k-1}+2} \in L \Leftrightarrow \dots \Leftrightarrow 1^{h_k-1} \in L \Leftrightarrow 1^{h_k} \in L$

由此得出：
$$
1^{h_{k-1}+1} \in L \Leftrightarrow 1^{h_k} \in L
$$
**当$n = h_k$时：**

$1^{h_k} \in L$（即$\mathbb{Z}$接受$1^{h_k}$）$\Leftrightarrow \mathbb{L}_{k-1}(1^{h_{k-1}+1}) = 0\Leftrightarrow 1^{h_{k-1}+1}\notin L$。

> 第$3$步的第一种操作。

由此得出：
$$
1^{h_k} \in L \Leftrightarrow 1^{h_{k-1}+1} \notin L
$$
于是得到了矛盾，证明了$L\notin\bold{NTIME}(f(n))$。

这个方法称为**迟对角线方法**。

## 1.13间隙定理

> [!NOTE]
>
> **定理1.10（间隙定理）**：设$r(x)\ge x$为可计算全函数。存在可计算全函数$b(x)$使得等式$\bold{TIME}(b(x))=\bold{TIME}(r(b(x)))$成立。

间隙定理说明：若不对时间函数做任何限制，即使多花指数级的时间也不可能多解决一个问题（说人话就是复杂性类之间不是连续分布的，而是存在**停滞区间**；在这些间隙里，增加时间或空间上限**不会增加可计算的语言集合**）。

这个咱们就不证了。

## 1.14神谕图灵机

一台**神谕图灵机**$\mathbb M^?$有一条额外的读写带，称为**神谕带**，以及三个额外的状态$q_{query},q_{yes},q_{no}$。一个**神谕**$B$是一个判定问题，即$\{0,1\}^*$的一个子集。用$\mathbb M^B$表示连接了神谕$B$的神谕图灵机$\mathbb M^?$。$\mathbb M^?$计算输入$x$时，当在$q_{query}$状态，若神谕带上的字符串$z\in B$，进入状态$q_{yes}$，否则进入状态$q_{no}$。

$\bold P^O$是带神谕$O$的具有多项式时间函数的神谕图灵机可判定的问题类。

$\bold{NP}^O$是带神谕$O$的具有多项式时间非确定神谕图灵机可接受的问题类。

$\bold{NP}^{O[k]}$代表$\bold{NP}^O$的一个子类。一个在$\bold{NP}^O$中的问题$L$也在$\bold {NP}^{O[k]}$中当且仅当存在多项式时间非确定神谕图灵机$\mathbb M^?$，$\mathbb M^O$接受$L$且$\mathbb M^O$的每次运行过程中问$O$问题的次数不超过$k$。

如果神谕$A$是多项式时间可判定问题，显然$\bold P^A=\bold P$，因为多项式时间内只能调用多项式次神谕，问题的大小也是多项式的，总时间仍然是多项式的。
$$
\bold{NP}^\bold{NP}=\bigcup_{A\in\bold{NP}}\bold{NP}^A
$$
$\bold{NP}^\bold{NP}=\bold{NP}^{SAT}$因为所有$NP$语言的问题都可以在多项式时间内转换成问$SAT$的问题。

$\bold{EXP}^\bold{EXP}=2-\bold{EXP}$。

> [!NOTE]
>
> **定义1.14**：若$\bold{A}^\bold{B}=\bold A$，称复杂性类$\bold B$对复杂性类$\bold A$是低的。

## 1.15归约

> [!note]
>
> **定义1.15**：可计算全函数$f:\{0,1\}^*\to\{0,1\}^*$是从问题$A$到问题$B$的**m-归约**，记为$A\le_mB$，若满足：对任意$0-1$串$x$，$x\in A$当且仅当$f(x)\in B$.

$A\le_mB$可理解为“$A$至少与$B$一样容易或至少一样难”。回想1.14节，我们其实做了一个**将不可判定的问题归约到另一个问题而推出另一个问题不可判定的事儿**。

> [!note]
>
> **定义1.16**：设$A$和$B$为判定问题。若存在神谕图灵机$\mathbb M^?$使得$\mathbb M^B$判定$A$，称$A$**图灵归约**到$B$，记为$A\le_TB$。

> [!note]
>
> **定义1.17**：若从$A$到$B$有一个多项式时间可计算的$m$-归约函数，称$A$可**卡普归约**到$B$，记为$A\le_KB$。

> [!note]
>
> **定义1.18**：若$A\in\bold{P}^B$，称$A$可**库克归约**到$B$，记为$A\le_CB$。

显然$A\le_CB\Leftrightarrow A\le_c\overline{B}$，翻转判定结果就好了。

> [!note]
>
> **命题3**：**图灵归约**具有传递性。

> [!note]
>
> **引理1.5**:$SAT\le_K3SAT$。

> [!note]
>
> **命题4**：$3SAT\le_KIS$。

## 1.16空间复杂性类

设$S:\mathbb N\to\mathbb N$，且$L\subseteq\{0,1\}^*$。若有常数$c$和判定语言$L$的图灵机$\mathbb M$，当输入$x$时，$\mathbb M(x)$计算时使用的**工作带**上的格子数不会超过$cS(n)$，那么$L\in\bold{SPACE}(S(n))$。称$S(n)$为$\mathbb M$的**空间函数**。

我们规定$S(n)\ge\log n$。

> 如果$\mathbb M$从输入带最左端走到最右端，若配置总数$N_{conf}=2^{O(S(n))}<n+1$，则必存在两个不同的位置$i<j$使得机器在到达$i$时与到达$j$时的全局配置相同。从此可构造循环（重复）——机器无法区分后续输入段，从而不能决定依赖于后面输入内容的语言。

> [!NOTE]
>
> **定义1.19**：若有图灵机在$O(S(n))$空间内计算函数$1^n\mapsto\llcorner S(n)\lrcorner$，称$S(n)$是**空间可构造的**。

> [!NOTE]
>
> **定义1.20**：若有图灵机当输入为$1^n$时准确地使用了工作带上的$S(n)$格后停机，称$S(n)$是**安全空间可构造的**。

给定图灵机$\mathbb M$和输入$x$，**格局图**$G_{\mathbb M,x}$的结点是$\mathbb M(x)$的格局。假定只有唯一的接受格局（$q_{start}$，读写头位置均为$0$，除最后一条工作带上输出$1$，其余均为空）。$C_{start}$表示起始格局，$C_{accept}$表示接受格局。$\mathbb M$接受$x\Leftrightarrow$在$G_{\mathbb M,x}$中有一条从$C_{start}$到$C_{accept}$的路径。$\mathbb M$接受$x$变成了**可达性问题**。

设$\mathbb M$的空间函数$S(n)$，状态的编码长度是常数，带子上的内容长度是$O(S(n))$，读写头位置的编码长度是$O(\log S(n))$。所以格局图$G_{\mathbb M,x}$的结点大小为$O(S(n))$，结点个数不会超过$2^{O(S(n))}$（为什么？）。

> 根据定义，工作带上使用的格子数不超过$c\cdot S(n)$。
>
> $\mathbb M$的状态数为$|Q|$。
>
> 设工作带的字母表为$\Gamma$。
>
> $k-1$条工作带的总内容组合数是$|\Gamma|^{(k-1) \cdot c \cdot S(n)}= 2^{\log_2(|\Gamma|)\cdot (k-1)\cdot c\cdot S(n))} = 2^{O(S(n))}$。
>
> 读写头可能的位置组合不超过$(S(n)+1)^{k-1}\cdot n=O(n\cdot S(n))$。

---

若有常数$c$和接受$L$的非确定图灵机$\mathbb N$，无论选择哪条计算路径，$\mathbb N$所有的工作带上的格子数不超过$cS(n)$，那么$L\in\bold{NSPACE}(S(n))$。

定义几个常用的空间复杂性类及它们的非确定版本：
$$
\begin{align}
\bold{L}&\stackrel{\text{def}}{=}\bold{SPACE}(\log(n))\\
\bold{NL}&\stackrel{\text{def}}{=}\bold{NSPACE}(\log(n))\\
\bold{PSPACE}&\stackrel{\text{def}}{=}\bigcup_{c>0}\bold{SPACE}(n^c)\\
\bold{NPSPACE}&\stackrel{\text{def}}{=}\bigcup_{c>0}\bold{NSPACE}(n^c)\\
\end{align}
$$
以一个例子理解对数空间复杂度，定义$\bold L$中的一个问题：
$$
\text{MULP}\stackrel{\text{def}}{=}\{(a,b,c)|a,b,c为二进制数,且a\cdot b=c\}
$$
用小学乘法就可以在对数空间判定$\text{MULP}$，只需要大小$|a|+|b|-1$的计数器记录在处理$a\cdot b$的哪一位，大小为$|c|+1$的计数器，用来存储进位。

> [!NOTE]
>
> **定理1.11（空间压缩定理）**：设图灵机$\mathbb M$在$S(n)$空间判定$L$。对任意$\epsilon>0$，存在图灵机$\mathbb M'$，$\mathbb M'$能在$\epsilon S(n)+1$空间内判定$L$。

这个定理的证明和**线性加速定理**类似，参考第三周作业。

> [!note]
>
> **定义1.19**：若有图灵机在$O(S(n))$空间内计算函数$1^n\mapsto\llcorner S(n)\lrcorner$，称$S(n)$是**空间可构造的**。

> [!note]
>
> **定义1.20**：若有图灵机当输入为$1^n$时准确地使用了工作带上的$S(n)$格后停机，称$S(n)$是**完全空间可构造的**。

这两个定义是等价的。

先说明$定义1.20\subseteq定义1.19$：

设$\mathbb M$在输入$1^n$上使用了$S(n)$格后停机，我们在这些区域内把$1^{S(n)}$转换成$\llcorner S(n)\lrcorner$。

再说明$定义1.19\subseteq定义1.20$：

有一台空间复杂性是$\epsilon S(n)+1$的图灵机计算$\llcorner S(n)\lrcorner$。假设$|\llcorner S(n)\lrcorner|+\epsilon S(n)+1\le S(n)$，那么我们可以用此图灵机通过连续减一操作准确地标注工作带上$S(n)$个格子。

> [!note]
>
> **引理1.6**：对任意格局$C$和$C'$，$\varphi_{\mathbb M,x}(C,C')=1$当且仅当从格局$C$可一步到达格局$C'$。表达式$\varphi_{\mathbb M,x}(C,C')$的求值可在$O(|\varphi_{\mathbb M,x}|)$时间和对数空间完成。

只需要对$\varphi_{\mathbb M,x}(C,C')$扫描一遍即可，用对数空间存储当前扫描的位置（试想只需要$\log|\varphi_{\mathbb M,x}|$的空间）。

> [!NOTE]
>
> **命题5**：设$S(n):\mathbb N\to\mathbb N$为空间可构造。有下述包含关系：
> $$
> \bold{TIME}(S(n))\subseteq\bold{SPACE}(S(n))\subseteq\bold{NSPACE}(S(n))\subseteq\bold{TIME}(2^{O(S(n))})
> $$

这是因为：

- 图灵机在$S(n)$时间内最多访问$S(n)$格。
- 确定图灵机是非确定图灵机的特例。
- 格局图结点个数不超过$2^{O(S(n))}$，相应时间内能构造出格局图。

$\bold{NP}\subseteq\bold{PSPACE}$，因为非确定图灵机每条路径可以在多项式完成，不同于时间，空间可以重复使用。

> [!NOTE]
>
> **定理1.12（通用图灵机，空间版本）**：存在通用图灵机，当输入空间函数为$S(n)$的图灵机$\mathbb M$和串$x$，通用图灵机在$cS(|x|)$空间内完成$\mathbb M(x)$的计算，其中$c$依赖于$\mathbb M$但不依赖于输入$x$。

因为通用图灵机只需要三条工作带：

- 一条用于记录$\mathbb M$的工作带内容。
- 一条实现计数器，记录读写头地址。
- 一条用于记录当前状态。

所用的空间为$O(S(n)+\log(S(n))+\log|Q|)$。

> [!NOTE]
>
> **定理1.13（空间谱系定理）**：设空间函数$f,g$为空间可构造，且$f(n)=o(g(n))$。包含关系$\bold{SPACE}(f(n))\subseteq\bold{SPACE}(g(n))$是严格的。

证明与**时间谱系定理**类似，本质是**定理1.12**。

## 1.17对数空间类

对时间复杂性而言，最小资源类是$\bold P$。对空间复杂性而言，最小资源类是$\bold L$。

引入一个比较问题的空间复杂性的方法：我们需要满足如下性质的**归约**：若$C$在空间复杂性类$\bold K$中并且$B$可归约到$C$，则$B$也在$\bold K$中。为此引入下述定义：

> [!NOTE]
>
> **定义1.21**：若下述条件满足，称$f:\{0,1\}^*\to\{0,1\}^*$为**隐式对数空间可计算**：
>
> 1. $\exist c.\forall x.|f(x)|\le c|x|^c$。
> 2. $\{\lang x,i\rang|i\le|f(x)|\}\in\bold L$。
> 3. $\{\lang x,i\rang|f(x)_i=1\}\in\bold L$。

在输入$x$后，隐式对数空间可计算函数$f$的输出长度有个多项式的界，这就是**条件一**。

> 如果输出长度是指数级的（例如$2^n$），那么要表示输出结果的下标就需要$O(n)$的空间。

如果我们能判定$i \le |f(x)|$，我们就可以通过对$i$进行二分查找（在$0$到$c|x|^c$之间），精确地找到$|f(x)|$的值，这就是**条件二**。

给定输入$x$和下标$i$，我们要能在对数空间内计算出$f(x)$的第$i$个比特是$0$还是$1$，这就是**条件三**。

> [!NOTE]
>
> **定义1.22**：问题$B$可**对数空间归约**到问题$C$，记为$B\le_L C$，若存在隐式对数空间可计算的从$B$到$C$的归约。

若$B\le_LC$，我们可推出结论说**$B$的空间复杂性不超过$C$的空间复杂性**或**$C$的空间复杂性至少与$B$的空间复杂性一样**，那么对数空间归约应当是传递的。

> [!NOTE]
>
> **引理1.7**：若$B\le_LC$和$C\le_LD$，则有$B\le_LD$。

设$f:B\to C$和$g:C\to D$为隐式对数空间可计算函数。从$B$到$D$的隐式对数空间可计算函数定义为：**输入$x$，计算$f(x)$，再计算$g(f(x))$**。

依赖**定义1.21**：

如果$\mathbb{M}_1$计算 $f(x)$，$\mathbb{M}_2$计算 $g(y)$。

在对数空间下，不能简单地先运行$\mathbb{M}_1$把$f(x)$写满输出带，再让$\mathbb{M}_2$读。因为$f(x)$的长度可能是多项式级的。

隐式计算的解决方案是把$f(x)$当作一个虚拟输入。

- 当$\mathbb{M}_2$需要读$f(x)$的第$i$位时，它暂停，调用$\mathbb{M}_1$的“按位计算”子程序（**条件三**）。
- $\mathbb{M}_1$算完第$i$位后把结果（$0$或$1$）传回给$\mathbb{M}_2$。
- 这样，我们就不需要存储完整的$f(x)$，从而保证了整个复合过程仍然在对数空间$\mathbf{L}$内。

---

对数归约可用另一类更直观的函数定义。函数$f:\{0,1\}^*\to\{0,1\}^*$是**对数空间可计算**当且仅当有一台图灵机计算$f$时使用了工作带上对数个格子，并且这台图灵机除了工作带之外，还有一条**只写输出带**，这条带被写入$f(x)$，读写头每写一次，向右移一格。

> 如果函数$f$是对数空间可计算的，且$\forall x\in A\Leftrightarrow f(x)\in B$，就说语言$A$可以对数空间归约到语言$B$。

> [!NOTE]
>
> **引理1.8**：隐式对数空间可计算函数就是对数空间可计算函数。

1. 对数空间可计算$\to$隐式对数空间可计算：

如果函数$f$可以被一个标准的$\mathbf{L}$-变换器$\mathbb{M}$计算出来，那么它自动满足隐式定义的所有条件：

- **多项式长度**：$\mathbf{L}$-变换器运行时间为多项式$T(n)$，所以输出长度$|f(x)| \le T(n)$，满足多项式有界。
- **按位可计算性**：要计算$f(x)$的第$i$位，我们只需让一个$\mathbf{L}$机器$\mathbb{M}'$**模拟**$\mathbb{M}$的完整计算过程。$\mathbb{M}'$在模拟过程中，只将前$i-1$位写入一个虚拟输出带，并在计算到第$i$位时，将该位的值作为自己的接受/拒绝结果。整个模拟过程的额外工作空间仍然是$O(\log n)$，因此满足$\mathbf{L}$可计算性。

2. 隐式对数空间可计算$\to$对数空间可计算：

如果函数$f$是隐式可计算的，我们可以构造一个标准的$\mathbf{L}$-变换器$\mathbb{M}$来输出整个$f(x)$：

- **构造$\mathbb{M}$**：$\mathbb{M}$使用其$O(\log n)$工作空间来存储一个计数器$i$，从$i=1$迭代到$|f(x)|$的最大长度。
- **生成输出**：在每次迭代中，$\mathbb{M}$调用隐式定义中的$\mathbf{L}$判定机，以确定$f(x)_i$的值（$0$或$1$）。
- **写入**：$\mathbb{M}$将得到的值顺序写入只写输出带。
- **空间分析**：计数器$i$只需要$O(\log n)$空间。每次调用按位判定机也只用$O(\log n)$空间。因此，总工作空间始终保持在$O(\log n)$。

---

若对所有$A\in\bold L$有$A\le_LA'$，称$A'$是**$L$-难的**。若$A'\in\bold L$是$L$-难的，称$A'$是$L$-完全的。

非确定对数空间类$\bold{NL}$有个标准的完全问题：
$$
\text{Reachability}=\{\lang G,s,t\rang|有向图G中从s到t有一条路径\}
$$

> [!NOTE]
>
> **定理1.14（可达性问题的复杂性）**：Reachability是$NL$-完全的。

设输入图有$n$个结点。从$s$出发，从当前结点$v$猜测一个邻居然后释放$v$所占用的空间，重复$n-1$次，看是否到达$t$。结点的长度是对数的，控制猜测次数的计数器（路径长度）也是对数的，所以Reachability在$\bold{NL}$中。

> 编码$n$个结点需要$\log(n)$位。
>
> 1.16中提到结点个数不会超过$2^{O(S(n))}$，因此$T(n)\le \text{结点个数}\le 2^{O(S(n))}$。
>
> 对于$\mathbf{NL}$类（对数空间$S(n) = O(\log n)$）。
>
> 所以$T(n)\le O(n)$，记录步数的计数器就是对数的。

设非确定图灵机$\mathbb N$在对数空间判定$L$。从$L$到Reachability的对数空间归约定义如下：
$$
x\mapsto\lang G_{\mathbb N,x},C_{\text{start}},C_{\text{accept}}\rang
$$
格局图$G_{\mathbb N,x}$可用邻接矩阵表示，矩阵的每个元素可在对数空间计算出（见引理1.6）。$C_{\text{start}}$和$C_{\text{accept}}$是固定的0-1串。因此上述归约是一个对数空间归约。

> [!NOTE]
>
> **推论1.4**：有向无环图的可达性问题是$NL$-完全的。

$DAG$当然在$NL$中。

试图证明它是$NL$-完全的：

把一个带环的图转化成一个$DAG$，且保持起点到终点的可达性不变。

设有向图$G=(V,E)$，结点数为$n$，构造一个新的图$G'$，它是一个$DAG$：

把$G$的每个结点$v$复制$n$份，标记为$(v, 0), (v, 1), \dots, (v, n-1)$，这里的第二个分量代表“步数”。

$G'$的结点集是$V \times \{0, \dots, n-1\}$。

如果在原图$G$中有一条边$u \to v$，那么在$G'$中，添加$(u, i) \to (v, i+1)$,这确保了$G'$是$DAG$。

这个转换并不需要显式地把$G'$全部存储在内存中（那需要多项式空间）。计算$G'$的结点和边只需要计数器（记录层数$i$）和原图的指针，这只需要$O(\log n)$的空间。因此，这是一个对数空间归约。

## 1.18多项式空间类

多项式空间类（$\bold{PSPACE}$）是一个非常大的类，它的难问题是对人类计算能力的极限挑战，人类发明的智力对抗游戏都在这个类里。

> [!CAUTION]
>
> 我们已经无奈地接受了一个事实，在这类博弈中，人类是玩不过多项式空间图灵机的。

我们提及一下跳过的QBF问题。

> [!NOTE]
>
> **定义1.13**：问题QBF定义为所有永真的量化布尔公式的集合。

一个QBF具有如下形式：
$$
\text{QBF} = Q_1 x_1 Q_2 x_2 \dots Q_n x_n \cdot \varphi(x_1, x_2, \dots, x_n)
$$

- $Q_i$是量词，可以是$\exists$或$\forall$。
- $x_i$是布尔变量。
- $\varphi$是一个没有量词的布尔公式。

> [!NOTE]
>
> **引理1.9**：QBF可在线性空间判定。

这很简单，爆搜就可以了：用线性空间存储爆搜的结果，用线性空间计算$\varphi$。

> [!NOTE]
>
> **定理1.15（斯托克迈尔-梅耶定理）**：QBF是$\bold{PSPACE}$-完全的。

根据上一条引理，只需证明QBF是$\bold{PSPACE}-$难的。

设$\mathbb M$在$S(|x|)$空间判定$L,x\in\{0,1\}^*$。目的是将格局图$G_{\mathbb M,x}$中一条从$C_{\text{start}}$到$C_{\text{accept}}$的路径用量化布尔公式表示。

定义$\psi_i(C',C'')$为真当且仅当从格局$C'$到格局$C''$有一条长度不超过$2^i$的路径。

$\psi_{i+1}(C', C'') = \exists C \forall X \forall Y \Big[ \big( (X=C' \land Y=C) \lor (X=C \land Y=C'') \big) \to \psi_i(X, Y) \Big]$（为什么？）。

$\psi_0(C,C')$定义为两格局一步可达。

依赖上式，有
$$
|\psi_{i+1}|=|\psi_i|+O(S(|x|))
$$

> 新引入的部分包括：
>
> 1. $\exists C, \forall X, \forall Y$：这就涉及到$3 \times O(S(n))$个布尔变量。
> 2. 逻辑判断$(X=C' \land Y=C) \dots$：这也涉及到$O(S(n))$个变量的比较

定义$\varphi_x$为$\psi_{S(|x|)}$，则$\varphi_x$中含有$O(S(n))^2$个变量,$|\varphi_x|=O(S(n)^2)$。

> 严格来说，考虑到每个变量的下标索引需要$O(\log S(n))$位来表示，总长度通常写为$O(S(n)^2 \log S(n))$，但这不影响它是多项式长度的结论。

由上一条引理，我们可以在多项式空间计算$\varphi_x$。按定义，$\mathbb M(x)=1$当且仅当$\varphi_x\in\text{QBF}$。

要输出$\varphi_x$，只需记住正在输出哪个$\psi_i$，只需维护一个长度是$\log S(|x|)$的计数器。

---

> [!note]
>
> **定理1.16（萨维奇定理）**$\bold{NSPACE}(S(n))\subseteq\bold{SPACE}(S(n)^2)$，这里$S(n)$为空间可构造函数。

根据**定理1.14**，我们讨论Reachability：

给定一个非确定性图灵机$\mathbb{M}$和输入$x$，我们想知道是否存在从起始格局$C_{start}$到接受格局$C_{accept}$的路径。

整个格局图的节点总数最多为$M = 2^{O(S(n))}$。如果存在路径，必存在一条长度不超过$M$的路径。

我们定义一个递归函数$Reach(u,v,k)$，判定是否存在一条从格局$u$到格局$v$的路径，且路径长度不超过$2^k$。

- 如果$u$能在$2^k$步内到达$v$，那么必然存在一个中间格局$w$，使得：
  1. $u$能在$2^{k-1}$步内到达$w$。
  2. $w$能在$2^{k-1}$步内到达$v$。

确定性图灵机$\mathbb D$将执行以下递归过程：

```python
function Reach(u, v, k):    
    # --- 基准情况 (Base Case) ---
    if k == 0:
        # 步数不超过 2^0 = 1，即一步可达或就在原地
        if (u == v) or (u -> v 是合法的一步):
            return True
        else:
            return False

    # --- 递归步骤 (Recursive Step) ---
    # 我们需要找到一个中间点 w
    # 注意：因为我们是确定性机器，我们不能猜 w，
    # 我们必须遍历所有可能的格局 w
    
    For w in All_Possible_Configurations:
        # 尝试验证：路径前半段存在 AND 路径后半段存在
        if Reach(u, w, k-1) == True AND Reach(w, v, k-1) == True:
            return True # 找到了一个有效的中间点，说明路径存在
            
    # 遍历完所有可能的 w 都没成功
    return False
```

为了判定机器是否接受 $x$，我们只需调用：
$$
\text{Reach}(C_{start}, C_{accept}, \log M)
$$


递归栈的最大深度由初始$k$决定，是$O(S(n))$。

在每一层递归`Reach(u, v, k)`中，需要存储：

1. 参数`u`和`v`：这是两个格局。每个格局需要记录纸带内容，大小是$O(S(n))$。
2. 局部变量`w`：当前循环枚举到的中间点。也是一个格局，大小是$O(S(n))$。
3. 参数`k`：一个计数器，大小是$O(1)$。

所以，每一层栈帧占用的空间是$O(S(n))$。

$$\text{Total Space} = O(S(n)) \times O(S(n)) = O(S(n)^2)$$

---

> [!note]
>
> **推论1.5**：$\bold{PSPACE}=\bold{NPSPACE}$。

由萨维奇定理，这很显然。

## 1.19对数空间的补封闭性

$\bold{NPSPACE}$在补运算下封闭，根据萨维奇定理：
$$
\begin{align}
\bold{coNPSPACE}&=\overline{\bold{NPSPACE}}\\
&=\overline{\bold{PSPACE}}\\
&=\bold{PSPACE}\\
&=\bold{NPSPACE}\\
\end{align}
$$
有一些~~非~~人类证明了$\bold{NL}$也在补运算下封闭。

> [!note]
>
> **定理1.17（伊默尔曼-斯泽勒普森伊定理）**：$\overline{\text{Reachability}}\in\bold{NL}$。

设计一对数空间非确定图灵机，$\mathbb N((G,s,t))=1$当且仅当从$s$到$t$没有路径。

设$G$有$n$个结点。$\forall i\in[n-1]$定义：

- $C_i$为从$s$出发$i$步之内到达的结点集合。这里我们认为一步可以不移动，所以显然有$C_1\subseteq C_2\subseteq\dots\subseteq C_{n-1}$。
- $c_i=|C_i|$，即$C_i$元素个数。

每个$c_i$长度是对数的（二进制表示），所以可以把固定数目$c_i$放在工作带上。注意不能是所有，否则空间复杂度要乘上一个$O(n)$。每个$C_i$一般含有线性多个结点，所以不能把$C_i$存放在工作带上。考虑下述非确定算法：

1. 设所有$c_i$为0。
2. 计算$c_1$。
3. 对所有$i\in[n-1]$，从$c_i$计算$c_{i+1}$。当成功计算出$c_{i+1}$后，删掉$c_i$。
4. 从$c_{n-1}$判定是否$t\notin C_{n-1}$。

第二步可在对数空间完成，至于第三步：

- 对每个不为$s$的结点$v$，若$v\in C_i$或从某个$C_i$中的结点$u$到$v$有条边，计数器$c_{i+1}$加$1$。

不能把$C_i$存放在工作带上，那么如何判断$v\in C_i$呢？

- 我们猜某个元素是否属于$C_i$，对于元素$v$，用Reachability的非确定算法验证即可。因为Reachability是$\bold{NL}$完全的，所以这一步仍然是对数空间的。验证通过，对计数器加一。

第四步重复上面操作即可。

> [!note]
>
> **推论1.6**：$\bold {coNL}=\bold{NL}$。

因为Reachability是$\text{NL}$-完全的，所以$\overline{\text{Reachability}}$是$\text{coNL}$-完全的。又$\overline{\text{Reachability}}\in\bold{NL}$，所以$\bold{coNL}\subseteq\bold{NL}$。于是$\bold{coNL}=\bold{NL}$。

> [!note]
>
> **推论1.7**：$\bold{coNSPACE}(S(n))=\bold{NSPACE}(S(n))$，这里$S(n)$为空间可构造的。

> [!note]
>
> **命题6**：$\text{2SAT}$是$\text{NL}$-完全的。

这是因为$2\text{SAT}$可以对数空间归约为有向图不可达问题，具体见作业。













